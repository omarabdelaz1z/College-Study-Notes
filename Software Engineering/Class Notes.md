# Software Engineering Quick Summary



- Types of software 
  - Application
  - Scientific
  - System
  - SPL (Software Product Lines)
  - Legacy
- Four categories of popular software
  - Web
  - Mobile
  - Cloud
  - SPL
- Myths:
  - A book of standards is not sufficient by itself, but rather by applying its rules.
  - Adding more developers to an already late project will make it later.
  - Outsourcing is not a silver bullet. A company that doesn't know how to manage its own products will inevitably fail.
  - Ambiguous objectives are not enough for software.
  - Early changes have lower impact on the product, and a lower cost.
  - Later changes have higher impact, higher cost, and more risks.
  - Programs are not done by the time of the first deliverable. They require maintenance. 
  - Quality assurances can be made before a program is complete, unlike popular belief.
  - Deliverables include code, docs, plans, and models.
  - Documentation doesn't slow down development. 
- The definition of great software:
  - Does what customers expect
  - Is maintainable
  - Is flexible
- The only constant in software is **change**
- The Eclipse IDE case study:
  - Do we not need features? 
  - Are we not using it to the fullest?
- Poor changes have bad consequences
- Tips for making great software:
  - Aim for extensibility and flexibility
  - Make classes cohesive
  - Encapsulate variables, implement unique
  - Interface > Implementation
  - Make classes about behaviour, not structure
- SOLID principles
  - Single responsibility
    - Each class should have one single responsibility
    - Fork & Spoon example
  - Open closed
    - Entities should be open for **extension** and closed for **modification**
    - The mixer example
    - Interfaces and Delegation can be used
  - Liskov substition
    - Instances should be replaceable with their subtypes
    - Chess board example
    - Inheritance and Delegation maybe used
  - Interface segregation (interface isolation)
    - No client should depend on interface methods it doesn't need
    - The charger example
    - Fat interfaces should be broken down into smaller units
  - Dependency inversion
    - Depend on abstractions instead of implementations
    - The power outlet example
    - Backend-Frontend example
    - Button-Lamp example